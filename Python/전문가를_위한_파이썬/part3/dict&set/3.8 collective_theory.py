# 집합(set) 이론
## 집합(set)은 고유한 객체의 모음으로서, `기본적으로 중복 항목을 제거한다.`
l = ['spam', 'eggs', 'spam', 'eggs']
set(l)  # {'eggs', 'spam'}
list(set(l))  # ['eggs', 'spam']

## 집합 요소는 반드시 해시할 수 있어야 한다.
## set은 해시 가능하지 않지만 frozenset은 해시 가능하므로, frozenset이 set에 들어갈 수 있다.

# TMI
## `list` 의 경우 hash 를 사용하지 않기 때문에 메모리를 적게 사용한다.
### 그리고 구현 특성 상 list 가 단순하여 iteration(반복)이 더 빠르다. / 메모리 측면에서 list 가 적게 쓴다.
### `list` 특히 `array list` 쓰는 것을 추천한다.
## `set` 의 경우 전체를 한번씩 확인을 해야 한다 그래서 overhead 가 발생한다. 즉 iteration(반복) 이 느리다.
### 메모리 사용 비용 증가

## set 은 기본적인 집합 연산을 구현한다.
### | 합집합, & 교집합, - 차집합
a = set([1,2,3]) # 비효율적 -> a = {1,2,3}
b = set([3,4,5]) # 비효율적 -> b = {3,4,5}

### 합집합
print(a | b)  # 1,2,3,4,5
print(len(a | b))  # 5

### 교집합
print(a & b)  # 3
print(len(a & b))  # 1

### 차집합
print(a - b)  # 1, 2
print(b - a)  # 4, 5

# 3.8.1 집합 리터럴
## 파이썬3 에서는 공집합 이외의 집합을 표준 문자열로 표현하기 위해 언제나 {} 구문을 사용한다.
s = {1}
print(type(s))  # <class 'set'>
print(s)  # {1}
s.pop()
print(s)  # set()

## {1,2,3} 과 같은 리터럴 집합 구문은 set([1,2,3]) 처럼 생성자를 호출하는 것 보다 더 빠르고, 가독성이 좋다.
## 생성자를 명시적으로 호출(set())하는 경우에는 파이썬이 생성자를 가져오기 위해 집합명을 검색하고, 리스트를 생성하고, 이 리스트를 생성자에 전달해야 하므로 더 느리다.
##* 반면 {1,2,3} 과 같은 리터럴 집합 구문을 처리하는 경우, 파이썬은 BUILD_SET 이라는 특수 바이트코드를 실행한다.

## 디스어셈블러 함수인 dis.dis() 를 이용해서 두 개의 연산에 대한 바이트코드를 살펴보자.
### 바이트 코드는 고급 언어로 작성된 소스 코드를 가상머신이 이해할 수 있는 중간 코드로 컴파일 한 것을 말한다.
from dis import dis
dis('{1}')  # 리터럴 표현식 {1} 에 대한 바이트코드로 디스어셈블 한다
dis('set({1})')  # 생성자 set([1]) 에 대한 바이트코드로 디스어셈블 한다

## fronzenset에 대한 별도의 리터럴 구문은 없으며, frozenset은 언제나 `생성자를 호출`해서 생성해야 한다

# 3.8.2 지능형 집합(set comprehension)
from unicodedata import name
print({chr(i) for i in range(32, 256) if 'SIGN' in name(chr(i), '')})

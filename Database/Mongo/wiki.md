# MongoDB

## 배경

요즘 시대에는 구글이나 페이스북과 같은 글로벌 서비스를 제공하는 회사가 늘어나면서 방대한 양의 데이터를 충분히 빠른 속도로 처리할 수 있는 데이터베이스에 대한 필요성이 대두되기 시작했다. 이런 대용량 데이터 서비스에서는 기존의 RDBMS 에서 처리하기는 힘들다.(비용적인 문제, 데이터를 분산하기 위해 수십, 수백대의 서버로 분산시켜야함) 물론 MySQL 같이 오픈소스 RDBMS 는 비용적인 문제를 해결해주기는 하였다. 하지만 이러한 MySQL 도 빅데이터를 처리하기에는 문제가 있다. 만약 엄청난 양의 데이터가 있고, 매번 데이터베이스 스키마에 맞게 데이터를 조작하여 작업을 해야 한다면 얼마나 비효율적이고 힘든 작업일까..

## 개념

MongoDB 는 배경에서 언급한 내용을 해결하기 위한 적합한 데이터베이스이다. 솔루션 자체적으로 분산 처리, 샤딩, 데이터 리벨런싱, 데이터 복제, 복구 등을 지원하고 무엇보다 Schema-Free(Schema-less) 한 구조이기에 대용량의 데이터 작업에 아주 효율적인 데이터베이스이다. 또한 일부 RDBMS의 기능을 제공하기도 한다. (인덱싱 등, 내부적으로 B-Tree 자료구조를 이용하여 인덱스를 관리)

- MongoDB 는 유연하고 JSON 과 유사한 문서에 데이터를 저장합니다. 즉, 필드는 문서마다 다를 수 있으며 시간에 따라 데이터 구조를 변경할 수 있습니다.
- 문서 모델은 응용 프로그램 코드의 객체에 매핑되므로 데이터를 쉽게 사용할 수 있습니다.
- 임시 쿼리, 인덱싱 및 실시간 집계는 데이터에 엑세스하고 분석하는 강력한 방법을 제공합니다.
- MongoDB는 기본적으로 분산 데이터베이스 이므로 고 가용성, 수평 확장 및 지리적 분포가 내장되어 있고 사용하기 쉽습니다.

## 특징

- MongoDB는 쿼리 결과로 커서를 반환하는데, 응용 프로그램이나 MongoDB 클라이언트 프로그램에서 커서를 통해 반복적으로 실제 도큐먼트를 가져올 수 있다. **MongoDB에서 쿼리 결과로 커서를 반환하는 이유는 쿼리의 결과를 클라이언트 서버의 메모리에 모두 담아두지 않아도 처리할 수 있게 하기 위해서다.** 물론 MongoDB 에서 커서를 읽을 때 마다 서버(MongoDB 서버) 에서 그때그때 도큐먼트를 가져오는 것은 아니고, 필요할 때 마다 지정된 페이지 사이즈 단위로 서버로부터 전송받아 MongoDB 클라이언트 서버에 캐싱한 후에 유저에게 서비스하는 것이다.
- NoSQL
- Schema-Free
- 비 관계형 데이터베이스
- database > collections > documents 구조로 document는 key-value 형태의 BSON(Nibary JSON) 으로 되어 있다.
- MongoDB 는 RDBMS의 SQL 을 사용하지는 않지만 MongoDB는 SQL 못지 않은 다양한 종류의 쿼리문을 지원한다. (필터링, 수집, 정렬, 정규 표현식 등) 또한 MongoDB 는 외래키를 명시적으로 지원하지는 않지만, 논리적으로 도큐만드 간의 관계(Embedded Document)를 만들어서 사용하는데에는 아무런 문제가 없다. 그리고 RDBMS와 같지는 않지만 "$lookup" 이라는 집계 기능을 이용하면 관계형 데이터베이스와 비슷한 형태의 조인 처리를 수행할 수 있다.(샤딩 환경에서는 제약이 존재)
- 스키마 프리가 아마도 MongoDB&RDBMS를 구분 지어줄 수 있는 가장 좋은 단어가 이다. 여기에서 스키마 프리는 테이블의 컬럼 수준에만 적용되는데, 사용할 컬럼을 미리 정의하지 않고 언제든지 동적으로 필요한 시점에 데이터를 저장할 수 있다는 것을 의미한다.(이러한 의미에서 Elasticsearch와 Solr 같은 검색엔진(색인)도 일종의 NoSQL이라 불리지 않을 까 싶다. 실제 샤딩,복제 등의 기능도 대부분의 검색엔진 솔루션 자체적으로 지원해준다.) 하지만 MongoDB는 모든 부분에 있어서 스키마 프리라고는 보기 힘들다. 다른 NoSQL 데이터베이스와는 달리 보조 인덱스를 생성할 수 있는데, MongoDB의 보조 인덱스는 항상 먼저 인덱스를 구성하는 필드를 먼저 정의해야 한다.

## 장점

- Flexibility: Schema-less 라서 어떤 형태의 데이터라도 저장할 수 있다.
- Performance: Read & Write 성능이 뛰어나다. 캐싱이나 많은 트래픽을 감당할 때 써도 좋다.
- Scalability: 애초부터 스케일아웃 구조를 채택해서 쉽게 운영이 가능하다. Auto Sharding 지원
- Deep Query ablilty: 문서지향적 Query Language를 사용하여 SQL 만큼 강력한 Query 성능을 제공한다.
- Conversion / Mapping: JSON 형태로 저장이 가능해서 직관적이고 개발이 편리하다.

## 단점

- JOIN 이 없다. join이 필요없도록 데이터 구조화 필요
- Memory Mapped File 으로 파일 엔진 DB이다. 메모리 관리를 OS 에게 위임한다. 메모리에 의존적, 메모리 크기가 성능을 좌우한다.
- SQL을 완전히 이전할 수 없다.
- B트리 인덱스를 사용하여 인덱스를 생성하는데, B트리는 크기가 커질수록 새로운 데이터를 입력하거나 삭제할 때 성능이 저하된다. 이런 B 트리의 특성 때문에 데이터를 넣어두면 변하지 않고 정보를 조회하는 데에 적합하다.

## Reference

- [MongoDB란(NoSQL, Document)](https://coding-start.tistory.com/273)